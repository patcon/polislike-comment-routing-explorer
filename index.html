<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Polis Metric Playground</title>
  <link href="https://cdn.jsdelivr.net/npm/nouislider@15.7.0/dist/nouislider.min.css" rel="stylesheet">
  <style>
    :root{
      --bg: #fafafa; --card:#ffffff; --muted:#666; --accent:#0b5fff;
      --agree: #16a34a; --pass: #f59e0b; --disagree: #ef4444; --empty: #ffffff;
      --radius: 8px; --gap: 12px;
    }
    html,body{height:100%;}
    body{font-family: Inter, Roboto, system-ui, -apple-system, 'Segoe UI', Arial; background:var(--bg); margin:0; padding:24px; color:#0f172a}
    h1{margin:0 0 8px 0; font-size:20px}
    p.lead{margin:0 0 18px 0; color:var(--muted)}

    /* container */
    .panel{max-width:1100px; margin:0 auto;}
    details{background:var(--card); border:1px solid #e6e9ef; padding:14px; border-radius:var(--radius); margin-bottom:14px}
    summary{font-weight:600; cursor:pointer}

    .row{display:flex; gap:var(--gap); align-items:flex-start}
    .col{flex:1}
    .col.small{flex:0 0 260px}

    label{font-size:13px;color:var(--muted)}
    input[type="text"]{width:100%; padding:8px;border-radius:6px;border:1px solid #dde3ef}
    .btn{background:var(--accent); color:white; border:none; padding:8px 12px;border-radius:6px; cursor:pointer}
    .links{display:flex; gap:8px; margin-top:8px}
    .link{font-size:13px; color:var(--accent); text-decoration:none}

    .textarea-container{display:flex; gap:12px}
    textarea{width:100%; min-height:120px; padding:10px; border-radius:6px; border:1px solid #e6e9ef; font-family: monospace; font-size:13px}

    .controls{background:var(--card); border:1px solid #e6e9ef; padding:14px; border-radius:var(--radius); margin-bottom:14px}
    .slider-wrapper{margin-bottom:12px}
    .output{background:var(--card); border:1px solid #e6e9ef; padding:12px; border-radius:6px}

    /* comments table visible below */
    .comments-table{background:var(--card); border:1px solid #e6e9ef; border-radius:6px; overflow:auto; max-height:320px}
    table{width:100%; border-collapse:collapse}
    th,td{padding:8px 10px; border-bottom:1px solid #f2f4f7; text-align:left; font-size:13px; word-wrap:break-word; word-break:break-word; max-width:300px}
    tr:hover{background:#f8fafc; cursor:pointer}
    td.small{width:90px; font-variant-numeric:tabular-nums}

    /* slider connect colors */
    .noUi-connect.c-empty{background:var(--empty) !important}
    .noUi-connect.c-agree{background:var(--agree) !important}
    .noUi-connect.c-pass{background:var(--pass) !important}
    .noUi-connect.c-disagree{background:var(--disagree) !important}

    footer{margin-top:18px; color:var(--muted); font-size:13px}

    /* Statement Cards Styles */
    .statement-cards{display:flex; flex-direction:column; gap:12px}
    .statement-card{
      background:var(--card);
      border:1px solid #e6e9ef;
      border-radius:var(--radius);
      padding:16px;
      position:relative;
      transition: all 0.2s ease;
      cursor: pointer;
    }
    .statement-card:hover{
      border-color: var(--accent);
      box-shadow: 0 2px 8px rgba(11, 95, 255, 0.1);
    }
    .statement-card-header{
      display:flex;
      justify-content:space-between;
      align-items:flex-start;
      margin-bottom:8px;
    }
    .statement-id{
      font-size:12px;
      color:var(--muted);
      background:#f8fafc;
      padding:2px 6px;
      border-radius:4px;
      font-weight:500;
    }
    .statement-priority{
      font-size:11px;
      color:var(--muted);
      background:#f0f9ff;
      padding:2px 6px;
      border-radius:4px;
    }
    .statement-text{
      font-size:15px;
      line-height:1.4;
      color:#0f172a;
      margin-bottom:8px;
    }
    .statement-stats{
      display:flex;
      gap:12px;
      font-size:12px;
      color:var(--muted);
    }
    .stat-item{
      display:flex;
      align-items:center;
      gap:4px;
    }
    .stat-agree{color:var(--agree)}
    .stat-disagree{color:var(--disagree)}
    .stat-pass{color:var(--pass)}

    @media (max-width:880px){ .row{flex-direction:column} .col.small{flex:1} .textarea-container{flex-direction:column} }
  </style>
</head>
<body>
  <div class="panel">
    <h1>Polis Metric Playground</h1>
    <p class="lead">Interactive slider &amp; simple table to explore Polis metrics. Paste API JSON (from the <code>curl</code> commands) into the boxes and click <em>Use Data</em>.</p>

    <details id="dataSection" open>
      <summary><strong>Load Polis Data</strong></summary>
      <div style="margin-top:12px" class="row">
        <div class="col small">
          <label for="conversation">Conversation (ID or URL)</label>
          <input id="conversation" type="text" placeholder="e.g. 6bkf4ujff9 or https://pol.is/6bkf4ujff9">
          <div style="height:8px"></div>
          <button id="loadData" class="btn">Generate URLs</button>
          <div class="links" id="linkRow" style="display:none">
            <a id="commentsUrl" class="link" href="#" target="_blank" rel="noreferrer noopener">Comments JSON</a>
            <a id="pcaUrl" class="link" href="#" target="_blank" rel="noreferrer noopener">PCA2 JSON</a>
          </div>
        </div>

        <div class="col">
          <label>Paste API responses</label>
          <div class="textarea-container">
            <textarea id="commentsInput" placeholder="Paste comments JSON here‚Ä¶"></textarea>
            <textarea id="pcaInput" placeholder="Paste PCA2 JSON here‚Ä¶"></textarea>
          </div>
          <div style="margin-top:8px"><button id="useData" class="btn">Use Data</button></div>
        </div>
      </div>
    </details>

    <!-- table must be visible after load -->
    <div class="comments-table" id="commentsTableContainer" style="margin-bottom:14px"></div>

    <div class="controls">
      <div class="slider-wrapper">
        <label>Response Distribution (green=agree, yellow=pass, red=disagree, white=remaining)</label>
        <div id="multiSlider" style="margin-top:10px"></div>
      </div>

      <div class="slider-wrapper">
        <label>Extremity</label>
        <div id="extremitySlider" style="margin-top:10px"></div>
      </div>

      <div class="slider-wrapper">
        <div class="row">
          <div class="col">
            <label>Moderation Status</label>
            <div style="margin-top:6px;">
              <label style="display:inline-block; margin-right:12px; font-weight:normal;">
                <input type="radio" name="moderationStatus" value="1" style="margin-right:4px;"> Moderated In
              </label>
              <label style="display:inline-block; margin-right:12px; font-weight:normal;">
                <input type="radio" name="moderationStatus" value="-1" style="margin-right:4px;"> Moderated Out
              </label>
              <label style="display:inline-block; font-weight:normal;">
                <input type="radio" name="moderationStatus" value="0" style="margin-right:4px;"> Unmoderated
              </label>
            </div>
          </div>
          <div class="col">
            <label>Meta Status</label>
            <div style="margin-top:6px;">
              <label style="font-weight:normal;">
                <input id="metaStatus" type="checkbox" style="margin-right:4px;"> This is a metadata statement
              </label>
            </div>
          </div>
        </div>
      </div>

      <div class="output">
        <strong>Values:</strong>
        <div id="values"></div>
      </div>
    </div>

    <!-- Statement Selection Section -->
    <div class="controls" style="margin-top: 20px;">
      <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 16px;">
        <h3 style="margin: 0; font-size: 18px;">Statement Selection (Polis-style)</h3>
        <button id="refreshStatements" class="btn" disabled>Refresh Selection</button>
      </div>
      <p style="color: var(--muted); font-size: 13px; margin: 0 0 16px 0;">
        All statements are displayed in weighted random order based on their priorities. Only non-moderated statements (moderation ‚â† -1) are included. Click "Refresh Selection" to re-randomize the order.
      </p>
      <div id="statementCards" class="statement-cards">
        <div style="color: var(--muted); text-align: center; padding: 40px;">
          Load data first to see statement selection
        </div>
      </div>
    </div>

    <footer>Tip: click any row in the table to populate the slider with that comment's counts.</footer>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/nouislider@15.7.0/dist/nouislider.min.js"></script>
  <script>
    const multiSlider = document.getElementById('multiSlider');
    const extremitySlider = document.getElementById('extremitySlider');
    const convoIdInput = document.getElementById('conversation');
    const commentsInput = document.getElementById('commentsInput');
    const pcaInput = document.getElementById('pcaInput');
    const loadDataBtn = document.getElementById('loadData');
    const useDataBtn = document.getElementById('useData');
    const commentsTableContainer = document.getElementById('commentsTableContainer');
    const linkRow = document.getElementById('linkRow');

    // Global variables to store data from math endpoint
    let totalParticipants = 100; // default fallback
    let pcaData = null; // store PCA data globally to access comment-extremity

    // --- RESTORE SAVED INPUTS ---
    convoIdInput.value = localStorage.getItem('conversation') || '';
    commentsInput.value = localStorage.getItem('commentsJSON') || '';
    pcaInput.value = localStorage.getItem('pcaJSON') || '';

    // --- INITIAL MULTISLIDER SETUP ---
    noUiSlider.create(multiSlider, {
      start: [33, 66, totalParticipants],
      connect: [true, true, true, true], // 3 handles + 4 connects
      range: { min: 0, max: totalParticipants },
      behaviour: 'none',
      tooltips: false // Disable built-in tooltips, we'll create custom ones
    });

    // Create custom tooltip elements
    const handles = multiSlider.querySelectorAll('.noUi-handle');
    handles.forEach((handle, index) => {
      const tooltip = document.createElement('div');
      tooltip.className = 'custom-tooltip';
      tooltip.style.cssText = `
        position: absolute;
        bottom: 100%;
        left: 50%;
        transform: translateX(-50%);
        background: #333;
        color: white;
        padding: 4px 8px;
        border-radius: 4px;
        font-size: 12px;
        white-space: nowrap;
        margin-bottom: 8px;
        pointer-events: none;
      `;
      handle.appendChild(tooltip);
    });

    // color segments
    const connectColors = ['#4CAF50', '#FFEB3B', '#F44336', '#FFFFFF']; // agree, pass, disagree, remainder
    function updateConnectColors() {
      multiSlider.querySelectorAll('.noUi-connect').forEach((el, i) => {
        el.style.background = connectColors[i] || '#ccc';
      });
    }
    updateConnectColors();

    // --- UPDATE TOOLTIPS TO SHOW COUNTS ---
    function updateTooltipCounts() {
      const values = multiSlider.noUiSlider.get().map(Number);
      const customTooltips = multiSlider.querySelectorAll('.custom-tooltip');
      if (customTooltips.length >= 3) {
        customTooltips[0].innerHTML = Math.round(values[0]); // agree count
        customTooltips[1].innerHTML = Math.round(values[1] - values[0]); // pass count
        customTooltips[2].innerHTML = Math.round(values[2] - values[1]); // disagree count
      }
    }

    // --- UPDATE TOOLTIP VALUES (raw counts) ---
    function updateTooltipsRawCounts(agree, pass, disagree) {
      const total = agree + pass + disagree;
      if (total === 0) return;

      // Set slider values to actual counts
      const v1 = agree;
      const v2 = agree + pass;
      const v3 = agree + pass + disagree;

      multiSlider.noUiSlider.set([v1, v2, v3]);
      updateTooltipCounts();
      updateConnectColors();
    }

    // --- FUNCTION TO UPDATE SLIDER RANGE ---
    function updateSliderRange(newMax) {
      totalParticipants = newMax;

      // Update the range of the multi-slider
      multiSlider.noUiSlider.updateOptions({
        range: { min: 0, max: newMax }
      });

      // Reset to proportional values based on new max
      const proportionalValues = [
        Math.round(newMax * 0.33),
        Math.round(newMax * 0.66),
        newMax
      ];
      multiSlider.noUiSlider.set(proportionalValues);
      updateTooltipCounts();
    }

    // --- SECONDARY SLIDER (EXTREMITY) ---
    noUiSlider.create(extremitySlider, { 
      start: [1], 
      tooltips: [true], 
      range: { min: 0, max: 5 } 
    });

    function probability(n, total, pseudo = 1) {
      // Laplace-smoothed probability (n + pseudo) / (total + 3*pseudo)
      return (n + pseudo) / (total + 3 * pseudo);
    }

    function importanceMetric(n_agree, n_disagree, n_total, extremity, pseudo = 1) {
      const n_pass = n_total - (n_agree + n_disagree);
      const prob_agree = probability(n_agree, n_total, pseudo);
      const prob_pass = probability(n_pass, n_total, pseudo);
      const prob_engagement = 1 - prob_pass;
      const importance = prob_agree * prob_engagement * (1 + extremity);
      return importance;
    }

    function priorityMetric(is_meta, n_agree, n_disagree, n_total, extremity, meta_priority = 7, pseudo = 1) {
      const importance = importanceMetric(n_agree, n_disagree, n_total, extremity, pseudo);
      const NO_VOTES_SCALE_FACTOR = 9;
      const newness_scale_factor = 1 + (NO_VOTES_SCALE_FACTOR - 1) * Math.pow(2, -(n_total / 5));
      let priority = importance * newness_scale_factor;
      if (is_meta) priority = meta_priority;
      const boosted_bias_priority = Math.pow(priority, 2);
      return boosted_bias_priority;
    }

    function updateValues() {
      const multi = multiSlider.noUiSlider.get().map(Number);
      const ext = Number(extremitySlider.noUiSlider.get()); // use extremity value directly

      // interpret slider sections (agree, pass, disagree, unseen)
      const agreePct = multi[0];
      const passPct = multi[1] - multi[0];
      const disagreePct = multi[2] - multi[1];
      const unseenPct = totalParticipants - multi[2];

      // convert slider values to actual counts
      const n_agree = agreePct;
      const n_disagree = disagreePct;
      const n_pass = passPct;
      const n_total = n_agree + n_disagree + n_pass;

      // compute metrics
      const importance = importanceMetric(n_agree, n_disagree, n_total, ext);
      const priority = priorityMetric(false, n_agree, n_disagree, n_total, ext);

      document.getElementById('values').innerHTML =
        `<div><strong>Handles:</strong> ${multi.map(v => v.toFixed(0)).join(', ')} (out of ${totalParticipants})<br>` +
        `<strong>Extremity:</strong> ${ext.toFixed(2)}<br>` +
        `<strong>Agree:</strong> ${n_agree.toFixed(0)} | <strong>Pass:</strong> ${n_pass.toFixed(0)} | <strong>Disagree:</strong> ${n_disagree.toFixed(0)}<br>` +
        `<strong>Total Votes:</strong> ${n_total.toFixed(0)} | <strong>Unseen:</strong> ${unseenPct.toFixed(0)}<br>` +
        `<strong>Importance:</strong> ${importance.toFixed(4)}<br>` +
        `<strong>Priority:</strong> ${priority.toFixed(4)}</div>`;
    }

    multiSlider.noUiSlider.on('update', function() {
      updateTooltipCounts();
      updateValues();
    });
    extremitySlider.noUiSlider.on('update', updateValues);
    updateTooltipCounts();
    updateValues();

    // --- LINKS AND TABLE ---
    loadDataBtn.addEventListener('click', () => {
      const input = convoIdInput.value.trim();
      if (!input) return alert('Enter conversation ID or URL');

      // Extract conversation ID from URL if it's a URL, otherwise use as-is
      let id = input;
      if (input.includes('pol.is/')) {
        // Extract ID from URL like https://pol.is/6bkf4ujff9 or pol.is/6bkf4ujff9
        const match = input.match(/pol\.is\/([a-zA-Z0-9]+)/);
        if (match) {
          id = match[1];
        }
      }

      localStorage.setItem('conversation', input);
      const commentsLink = `https://pol.is/api/v3/comments?conversation_id=${id}&moderation=true&include_voting_patterns=true`;
      const pcaLink = `https://pol.is/api/v3/math/pca2?conversation_id=${id}`;
      document.getElementById('commentsUrl').href = commentsLink;
      document.getElementById('pcaUrl').href = pcaLink;
      linkRow.style.display = 'flex';
    });

    useDataBtn.addEventListener('click', async () => {
      if (!commentsInput.value.trim()) return alert('Paste comments JSON');
      try {
        localStorage.setItem('commentsJSON', commentsInput.value);
        localStorage.setItem('pcaJSON', pcaInput.value);
        const comments = JSON.parse(commentsInput.value);

        // Try to get "n" from PCA data if available and store PCA data globally
        if (pcaInput.value.trim()) {
          try {
            pcaData = JSON.parse(pcaInput.value);
            if (pcaData.n && typeof pcaData.n === 'number') {
              console.log('Found n value in PCA data:', pcaData.n);
              updateSliderRange(pcaData.n);
            }
            if (pcaData.pca && pcaData.pca['comment-extremity']) {
              console.log('Found comment-extremity data:', pcaData.pca['comment-extremity'].length, 'entries');
            }
            if (pcaData['comment-priorities']) {
              console.log('Found comment-priorities data:', Object.keys(pcaData['comment-priorities']).length, 'entries');
            }
          } catch (pcaError) {
            console.warn('Could not parse PCA data:', pcaError);
            pcaData = null;
          }
        }

        // --- table header reordered: agree, pass, disagree, extremity, comment-priorities, moderation status, meta ---
        let html = '<table><thead><tr><th>ID</th><th>Text</th><th class="small">Agree</th><th class="small">Pass</th><th class="small">Disagree</th><th class="small">Extremity</th><th class="small">Priority</th><th class="small">Moderation Status</th><th class="small">Meta</th></tr></thead><tbody>';

        // Sort comments by statement ID (tid) before displaying
        const sortedComments = comments.sort((a, b) => {
          const tidA = parseInt(a.tid) || 0;
          const tidB = parseInt(b.tid) || 0;
          return tidA - tidB;
        });

        sortedComments.forEach(c => {
          const text = String(c.txt || '').replace(/[\r\n]+/g, ' ').slice(0, 120);
          const statementId = parseInt(c.tid) || 0;

          // Get extremity value if available
          let extremityValue = '';
          if (pcaData && pcaData.pca && pcaData.pca['comment-extremity'] && pcaData['comment-priorities']) {
            const extremityArray = pcaData.pca['comment-extremity'];
            const priorityKeys = Object.keys(pcaData['comment-priorities']).sort((a, b) => parseInt(a) - parseInt(b));

            // Find the index of this statement ID in the sorted priority keys
            const keyIndex = priorityKeys.indexOf(statementId.toString());
            if (keyIndex >= 0 && keyIndex < extremityArray.length && extremityArray[keyIndex] !== null && extremityArray[keyIndex] !== undefined) {
              extremityValue = extremityArray[keyIndex].toFixed(2);
            }
          }

          // Get comment-priorities value if available (not in pca sublevel)
          let commentPriority = '';
          if (pcaData && pcaData['comment-priorities']) {
            const priorityObject = pcaData['comment-priorities'];
            // Use the same key format as comment-extremity (statement ID as key)
            const priorityValue = priorityObject[statementId.toString()];
            if (priorityValue !== null && priorityValue !== undefined) {
              commentPriority = priorityValue.toFixed(2);
            }
          }

          // Get moderation status (show 0 if undefined/null, otherwise show the actual value)
          const moderationStatus = c.mod !== undefined && c.mod !== null ? c.mod : '0';

          // Get is_meta status and create checkbox
          const isMeta = c.is_meta || false;
          const metaCheckbox = isMeta ? '<input type="checkbox" checked disabled>' : '<input type="checkbox" disabled>';

          html += `<tr data-agree='${c.agree_count}' data-pass='${c.pass_count}' data-disagree='${c.disagree_count}'>` +
                  `<td>${c.tid}</td>` +
                  `<td>${text}</td>` +
                  `<td class="small">${c.agree_count}</td>` +
                  `<td class="small">${c.pass_count}</td>` +
                  `<td class="small">${c.disagree_count}</td>` +
                  `<td class="small">${extremityValue}</td>` +
                  `<td class="small">${commentPriority}</td>` +
                  `<td class="small">${moderationStatus}</td>` +
                  `<td class="small">${metaCheckbox}</td>` +
                  `</tr>`;
        });

        html += '</tbody></table>';
        commentsTableContainer.innerHTML = html;
        document.getElementById('dataSection').open = false;

        commentsTableContainer.querySelectorAll('tr[data-agree]').forEach(row => {
          row.addEventListener('click', () => {
            const agree = Number(row.dataset.agree);
            const pass = Number(row.dataset.pass);
            const disagree = Number(row.dataset.disagree);
            updateTooltipsRawCounts(agree, pass, disagree);

            // Set extremity slider based on statement ID if PCA data is available
            const statementId = row.querySelector('td:first-child').textContent;
            if (pcaData && pcaData.pca && pcaData.pca['comment-extremity'] && pcaData['comment-priorities']) {
              const extremityArray = pcaData.pca['comment-extremity'];
              const priorityKeys = Object.keys(pcaData['comment-priorities']).sort((a, b) => parseInt(a) - parseInt(b));

              // Find the index of this statement ID in the sorted priority keys
              const keyIndex = priorityKeys.indexOf(statementId.toString());
              if (keyIndex >= 0 && keyIndex < extremityArray.length && extremityArray[keyIndex] !== null && extremityArray[keyIndex] !== undefined) {
                const extremityValue = extremityArray[keyIndex];
                extremitySlider.noUiSlider.set(extremityValue);
                console.log(`Set extremity for statement ${statementId} to ${extremityValue} (index ${keyIndex})`);
              }
            }

            // Populate moderation status and meta fields
            const cells = row.querySelectorAll('td');
            const moderationStatusCell = cells[7]; // 8th column (0-indexed)
            const metaCell = cells[8]; // 9th column (0-indexed)

            // Set moderation status radio buttons
            if (moderationStatusCell) {
              const moderationValue = moderationStatusCell.textContent.trim();
              const radioButtons = document.querySelectorAll('input[name="moderationStatus"]');
              radioButtons.forEach(radio => {
                radio.checked = radio.value === moderationValue;
              });
            }

            // Set meta status field
            const metaStatusInput = document.getElementById('metaStatus');
            if (metaStatusInput && metaCell) {
              const checkbox = metaCell.querySelector('input[type="checkbox"]');
              metaStatusInput.checked = checkbox ? checkbox.checked : false;
            }
          });
        });
      } catch (e) {
        alert('Invalid JSON data: ' + e.message);
      }
    });

    // --- STATEMENT SELECTION FUNCTIONALITY ---
    let commentsData = null;
    const refreshStatementsBtn = document.getElementById('refreshStatements');
    const statementCardsContainer = document.getElementById('statementCards');

    // Weighted random selection function - now returns all statements in weighted random order
    function weightedRandomSelection(items, weights) {
      if (items.length === 0) return [];

      const selected = [];
      const availableItems = [...items];
      const availableWeights = [...weights];

      // Select all items in weighted random order
      while (availableItems.length > 0) {
        const totalWeight = availableWeights.reduce((sum, weight) => sum + weight, 0);
        if (totalWeight === 0) {
          // If no weights left, just add remaining items in order
          selected.push(...availableItems);
          break;
        }

        let random = Math.random() * totalWeight;
        let selectedIndex = 0;

        for (let j = 0; j < availableWeights.length; j++) {
          random -= availableWeights[j];
          if (random <= 0) {
            selectedIndex = j;
            break;
          }
        }

        selected.push(availableItems[selectedIndex]);
        availableItems.splice(selectedIndex, 1);
        availableWeights.splice(selectedIndex, 1);
      }

      return selected;
    }

    // Generate statement cards
    function generateStatementCards() {
      if (!commentsData || !pcaData || !pcaData['comment-priorities']) {
        statementCardsContainer.innerHTML = '<div style="color: var(--muted); text-align: center; padding: 40px;">No data available for statement selection</div>';
        return;
      }

      // Filter out moderated statements (mod === -1)
      const activeStatements = commentsData.filter(comment => comment.mod !== -1);

      if (activeStatements.length === 0) {
        statementCardsContainer.innerHTML = '<div style="color: var(--muted); text-align: center; padding: 40px;">No active statements available</div>';
        return;
      }

      // Get priorities for active statements
      const statementsWithPriorities = activeStatements.map(comment => {
        const priority = pcaData['comment-priorities'][comment.tid.toString()] || 0;
        return { comment, priority };
      }).filter(item => item.priority > 0);

      if (statementsWithPriorities.length === 0) {
        statementCardsContainer.innerHTML = '<div style="color: var(--muted); text-align: center; padding: 40px;">No statements with priorities available</div>';
        return;
      }

      // Perform weighted random selection for ALL statements
      const statements = statementsWithPriorities.map(item => item.comment);
      const priorities = statementsWithPriorities.map(item => item.priority);
      const selectedStatements = weightedRandomSelection(statements, priorities);

      // Generate HTML for ALL selected statements
      let html = '';
      selectedStatements.forEach(comment => {
        const priority = pcaData['comment-priorities'][comment.tid.toString()];
        const text = String(comment.txt || '').trim();

        html += `
          <div class="statement-card" data-tid="${comment.tid}">
            <div class="statement-card-header">
              <span class="statement-id">ID: ${comment.tid}</span>
              <span class="statement-priority">Priority: ${priority.toFixed(2)}</span>
            </div>
            <div class="statement-text">${text}</div>
            <div class="statement-stats">
              <div class="stat-item stat-agree">
                <span>üëç</span>
                <span>${comment.agree_count || 0}</span>
              </div>
              <div class="stat-item stat-pass">
                <span>‚ûñ</span>
                <span>${comment.pass_count || 0}</span>
              </div>
              <div class="stat-item stat-disagree">
                <span>üëé</span>
                <span>${comment.disagree_count || 0}</span>
              </div>
            </div>
          </div>
        `;
      });

      statementCardsContainer.innerHTML = html;

      // Add click handlers to statement cards
      statementCardsContainer.querySelectorAll('.statement-card').forEach(card => {
        card.addEventListener('click', () => {
          const tid = card.dataset.tid;
          const comment = selectedStatements.find(c => c.tid.toString() === tid);
          if (comment) {
            // Update sliders with this statement's data
            updateTooltipsRawCounts(comment.agree_count || 0, comment.pass_count || 0, comment.disagree_count || 0);

            // Set extremity if available
            if (pcaData && pcaData.pca && pcaData.pca['comment-extremity'] && pcaData['comment-priorities']) {
              const extremityArray = pcaData.pca['comment-extremity'];
              const priorityKeys = Object.keys(pcaData['comment-priorities']).sort((a, b) => parseInt(a) - parseInt(b));
              const keyIndex = priorityKeys.indexOf(tid);
              if (keyIndex >= 0 && keyIndex < extremityArray.length && extremityArray[keyIndex] !== null) {
                extremitySlider.noUiSlider.set(extremityArray[keyIndex]);
              }
            }

            // Set moderation status
            const radioButtons = document.querySelectorAll('input[name="moderationStatus"]');
            const moderationValue = (comment.mod !== undefined && comment.mod !== null ? comment.mod : '0').toString();
            radioButtons.forEach(radio => {
              radio.checked = radio.value === moderationValue;
            });

            // Set meta status
            const metaStatusInput = document.getElementById('metaStatus');
            if (metaStatusInput) {
              metaStatusInput.checked = comment.is_meta || false;
            }

            // Scroll to controls
            document.querySelector('.controls').scrollIntoView({ behavior: 'smooth', block: 'start' });
          }
        });
      });
    }

    // Refresh button handler
    refreshStatementsBtn.addEventListener('click', generateStatementCards);

    // Modify the existing useData event listener to also handle statement generation
    const originalUseDataClick = useDataBtn.onclick;
    useDataBtn.addEventListener('click', async (e) => {
      // Let the original handler run first, but we need to capture the comments data
      if (!commentsInput.value.trim()) return;

      try {
        const comments = JSON.parse(commentsInput.value);
        commentsData = comments; // Store for statement selection

        // Enable refresh button once data is loaded
        refreshStatementsBtn.disabled = false;

        // Generate initial statement cards after a short delay to ensure PCA data is processed
        setTimeout(() => {
          if (pcaData && pcaData['comment-priorities']) {
            generateStatementCards();
          }
        }, 100);

      } catch (e) {
        console.error('Error parsing comments data for statement selection:', e);
      }
    });
  </script>
</body>
</html>
